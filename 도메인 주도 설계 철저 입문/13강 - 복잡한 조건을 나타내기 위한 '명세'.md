# 복잡한 조건을 나타내기 위한 명세

## 13.1 명세란?

> 명세란 객체를 평가하는 것이다.

객체가 어떠한 상태일 수 있는 지 정의하는 것을 보통 명세라고 한다.
'사람은 19세가 넘으면 `성인`으로 분류한다.` 등과 같은 것이 명세이며 이는 객체를 평가해야만 나오는 것이다.
측 어떠한 `함수`는 명세일 수 있다.

### 13.1.1 객체의 복잡한 평가 절차

- 간점 참조하고 있는 엔티티에 대해서 특정 평가가 직접 참조할 필요성이 존재한다면,
    - application service에서 하는 것은 도메인 규칙이 외부로 유출된 것이고
    - 엔티티가 직접 repository를 받는 것은 얼핏보면 그럴싸해보이지만, repository는 도메인 개념이 아니라 영속성 개념에서 유례된 것이라 적절하지 못함.

### 13.1.2 이 문제의 해결책 - 명세

- 명세(Specification) 클래스를 별도로 두고 여기에서 마치 도메인 서비스처럼 레포지토리 참조하여 적절한 평가 후 반환한다.
- 객체 평가 코드가 항상 객체에만 존재해야할 필요는 없다. → 이 객체가 무엇이고 어떤 역할을 하는지 관점에 따라서 다르기에 적절히 분리해야한다.

### 13.1.3 리포지토리를 되도록 사용하지 않기

- 명세도 도메인 객체이므로 입출력이 최대한 없어야한다는 주장도 있음
- 이런 경우 특수 목적의 컬렉션 객체를 정의하여 애플리케이션 서비스에서 만들어서 사용하는 방법도 존재함.

```kotlin
class CircleCollection {
    List<User> members;
    string name;
    
    public bool isSomething() { } 
}
```

## 13.2 명세와 리포지토리의 조합

검색과 같은 기능을 리포지토리의 메서드로 정의하면, 중요한 도메인 규칙이 외부로 빠져나가는 것으로 볼 수도 있다.

### 13.2.1 추천 서클 검색 기능으로 본 복잡한 검색

리포지토리에 추천 검색 기능을 만들게 되면 구현에 따라서 도메인의 규칙이 좌지우지 된다.

### 13.2.2 명세를 이용한 해결책

명세를 추상화하고 리포지토리에서 이 명세를 받아 씀으로써 리포지토리의 구현 변성 문제도 해결하고 우아하게 적절한 객체를 받아올 수 있다.

### 13.2.3 명세와 리포지토리를 함께 사용할 때 생기는 성능 문제

인메모리에서 해당 객체가 적절한지 평가하므로, 데이터가 많은 경우 성능상의 문제가 충분히 발생할 수 있다.

### 13.2.4 복잡한 쿼리는 리드모델로

- 페이징처리나 추천 시스템과 같은 경우는 복잡한 읽기작업과 성능 문제를 야기하므로, 이러한 요구사항에 대해서는 도메인 객체의 제약에서도 벗어나는 방법도 꽤나 유효한 방법이다.
- 인프라 모듈에서 직접 질의하는 서비스를 만들어 해결한다.
- 이는 CQS, CQRS 등에서 기인한 내용이기도 하다.
